// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: svm.proto

#ifndef PROTOBUF_INCLUDED_svm_2eproto
#define PROTOBUF_INCLUDED_svm_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_svm_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_svm_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_svm_2eproto();
namespace ShadowVM {
class BulkInfo;
class BulkInfoDefaultTypeInternal;
extern BulkInfoDefaultTypeInternal _BulkInfo_default_instance_;
class ColumnInfo;
class ColumnInfoDefaultTypeInternal;
extern ColumnInfoDefaultTypeInternal _ColumnInfo_default_instance_;
class DependencyInfo;
class DependencyInfoDefaultTypeInternal;
extern DependencyInfoDefaultTypeInternal _DependencyInfo_default_instance_;
class GraphInfo;
class GraphInfoDefaultTypeInternal;
extern GraphInfoDefaultTypeInternal _GraphInfo_default_instance_;
class HelloReply;
class HelloReplyDefaultTypeInternal;
extern HelloReplyDefaultTypeInternal _HelloReply_default_instance_;
class HelloRequest;
class HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class ObjectInfo;
class ObjectInfoDefaultTypeInternal;
extern ObjectInfoDefaultTypeInternal _ObjectInfo_default_instance_;
class OperatorInfo;
class OperatorInfoDefaultTypeInternal;
extern OperatorInfoDefaultTypeInternal _OperatorInfo_default_instance_;
class OperatorInfo_ArgsEntry_DoNotUse;
class OperatorInfo_ArgsEntry_DoNotUseDefaultTypeInternal;
extern OperatorInfo_ArgsEntry_DoNotUseDefaultTypeInternal _OperatorInfo_ArgsEntry_DoNotUse_default_instance_;
class PipelineInfo;
class PipelineInfoDefaultTypeInternal;
extern PipelineInfoDefaultTypeInternal _PipelineInfo_default_instance_;
class Ret;
class RetDefaultTypeInternal;
extern RetDefaultTypeInternal _Ret_default_instance_;
class TestReply;
class TestReplyDefaultTypeInternal;
extern TestReplyDefaultTypeInternal _TestReply_default_instance_;
class TestRequest;
class TestRequestDefaultTypeInternal;
extern TestRequestDefaultTypeInternal _TestRequest_default_instance_;
class UDFInfo;
class UDFInfoDefaultTypeInternal;
extern UDFInfoDefaultTypeInternal _UDFInfo_default_instance_;
}  // namespace ShadowVM
namespace google {
namespace protobuf {
template<> ::ShadowVM::BulkInfo* Arena::CreateMaybeMessage<::ShadowVM::BulkInfo>(Arena*);
template<> ::ShadowVM::ColumnInfo* Arena::CreateMaybeMessage<::ShadowVM::ColumnInfo>(Arena*);
template<> ::ShadowVM::DependencyInfo* Arena::CreateMaybeMessage<::ShadowVM::DependencyInfo>(Arena*);
template<> ::ShadowVM::GraphInfo* Arena::CreateMaybeMessage<::ShadowVM::GraphInfo>(Arena*);
template<> ::ShadowVM::HelloReply* Arena::CreateMaybeMessage<::ShadowVM::HelloReply>(Arena*);
template<> ::ShadowVM::HelloRequest* Arena::CreateMaybeMessage<::ShadowVM::HelloRequest>(Arena*);
template<> ::ShadowVM::ObjectInfo* Arena::CreateMaybeMessage<::ShadowVM::ObjectInfo>(Arena*);
template<> ::ShadowVM::OperatorInfo* Arena::CreateMaybeMessage<::ShadowVM::OperatorInfo>(Arena*);
template<> ::ShadowVM::OperatorInfo_ArgsEntry_DoNotUse* Arena::CreateMaybeMessage<::ShadowVM::OperatorInfo_ArgsEntry_DoNotUse>(Arena*);
template<> ::ShadowVM::PipelineInfo* Arena::CreateMaybeMessage<::ShadowVM::PipelineInfo>(Arena*);
template<> ::ShadowVM::Ret* Arena::CreateMaybeMessage<::ShadowVM::Ret>(Arena*);
template<> ::ShadowVM::TestReply* Arena::CreateMaybeMessage<::ShadowVM::TestReply>(Arena*);
template<> ::ShadowVM::TestRequest* Arena::CreateMaybeMessage<::ShadowVM::TestRequest>(Arena*);
template<> ::ShadowVM::UDFInfo* Arena::CreateMaybeMessage<::ShadowVM::UDFInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ShadowVM {

enum DependencyInfo_Type {
  DependencyInfo_Type_Whole = 0,
  DependencyInfo_Type_HashPartition = 1,
  DependencyInfo_Type_RangePartition = 2,
  DependencyInfo_Type_DependencyInfo_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  DependencyInfo_Type_DependencyInfo_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool DependencyInfo_Type_IsValid(int value);
const DependencyInfo_Type DependencyInfo_Type_Type_MIN = DependencyInfo_Type_Whole;
const DependencyInfo_Type DependencyInfo_Type_Type_MAX = DependencyInfo_Type_RangePartition;
const int DependencyInfo_Type_Type_ARRAYSIZE = DependencyInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* DependencyInfo_Type_descriptor();
inline const ::std::string& DependencyInfo_Type_Name(DependencyInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    DependencyInfo_Type_descriptor(), value);
}
inline bool DependencyInfo_Type_Parse(
    const ::std::string& name, DependencyInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DependencyInfo_Type>(
    DependencyInfo_Type_descriptor(), name, value);
}
enum OperatorInfo_Type {
  OperatorInfo_Type_Source = 0,
  OperatorInfo_Type_Loader = 1,
  OperatorInfo_Type_Filter = 2,
  OperatorInfo_Type_Map = 3,
  OperatorInfo_Type_ReduceBy = 4,
  OperatorInfo_Type_SortBy = 5,
  OperatorInfo_Type_JoinWith = 6,
  OperatorInfo_Type_Sink = 7,
  OperatorInfo_Type_OperatorInfo_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  OperatorInfo_Type_OperatorInfo_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool OperatorInfo_Type_IsValid(int value);
const OperatorInfo_Type OperatorInfo_Type_Type_MIN = OperatorInfo_Type_Source;
const OperatorInfo_Type OperatorInfo_Type_Type_MAX = OperatorInfo_Type_Sink;
const int OperatorInfo_Type_Type_ARRAYSIZE = OperatorInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* OperatorInfo_Type_descriptor();
inline const ::std::string& OperatorInfo_Type_Name(OperatorInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    OperatorInfo_Type_descriptor(), value);
}
inline bool OperatorInfo_Type_Parse(
    const ::std::string& name, OperatorInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OperatorInfo_Type>(
    OperatorInfo_Type_descriptor(), name, value);
}
enum OperatorInfo_Preference {
  OperatorInfo_Preference_CPU = 0,
  OperatorInfo_Preference_GPU = 1,
  OperatorInfo_Preference_NO = 2,
  OperatorInfo_Preference_OperatorInfo_Preference_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  OperatorInfo_Preference_OperatorInfo_Preference_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool OperatorInfo_Preference_IsValid(int value);
const OperatorInfo_Preference OperatorInfo_Preference_Preference_MIN = OperatorInfo_Preference_CPU;
const OperatorInfo_Preference OperatorInfo_Preference_Preference_MAX = OperatorInfo_Preference_NO;
const int OperatorInfo_Preference_Preference_ARRAYSIZE = OperatorInfo_Preference_Preference_MAX + 1;

const ::google::protobuf::EnumDescriptor* OperatorInfo_Preference_descriptor();
inline const ::std::string& OperatorInfo_Preference_Name(OperatorInfo_Preference value) {
  return ::google::protobuf::internal::NameOfEnum(
    OperatorInfo_Preference_descriptor(), value);
}
inline bool OperatorInfo_Preference_Parse(
    const ::std::string& name, OperatorInfo_Preference* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OperatorInfo_Preference>(
    OperatorInfo_Preference_descriptor(), name, value);
}
enum StoType {
  Disk = 0,
  HostMem = 1,
  DeviceMem = 2,
  SharedMem = 3,
  StoType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  StoType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool StoType_IsValid(int value);
const StoType StoType_MIN = Disk;
const StoType StoType_MAX = SharedMem;
const int StoType_ARRAYSIZE = StoType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StoType_descriptor();
inline const ::std::string& StoType_Name(StoType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StoType_descriptor(), value);
}
inline bool StoType_Parse(
    const ::std::string& name, StoType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StoType>(
    StoType_descriptor(), name, value);
}
enum ValType {
  Byte = 0,
  Int16 = 1,
  Int32 = 2,
  Int64 = 3,
  Float16 = 4,
  Float32 = 5,
  Float64 = 6,
  String = 7,
  Tensor = 8,
  ValType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ValType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ValType_IsValid(int value);
const ValType ValType_MIN = Byte;
const ValType ValType_MAX = Tensor;
const int ValType_ARRAYSIZE = ValType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ValType_descriptor();
inline const ::std::string& ValType_Name(ValType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ValType_descriptor(), value);
}
inline bool ValType_Parse(
    const ::std::string& name, ValType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ValType>(
    ValType_descriptor(), name, value);
}
// ===================================================================

class HelloRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShadowVM.HelloRequest) */ {
 public:
  HelloRequest();
  virtual ~HelloRequest();

  HelloRequest(const HelloRequest& from);

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HelloRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(HelloRequest* other);
  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelloRequest* New() const final {
    return CreateMaybeMessage<HelloRequest>(nullptr);
  }

  HelloRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HelloRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HelloRequest& from);
  void MergeFrom(const HelloRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:ShadowVM.HelloRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svm_2eproto;
};
// -------------------------------------------------------------------

class TestRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShadowVM.TestRequest) */ {
 public:
  TestRequest();
  virtual ~TestRequest();

  TestRequest(const TestRequest& from);

  inline TestRequest& operator=(const TestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestRequest(TestRequest&& from) noexcept
    : TestRequest() {
    *this = ::std::move(from);
  }

  inline TestRequest& operator=(TestRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TestRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestRequest* internal_default_instance() {
    return reinterpret_cast<const TestRequest*>(
               &_TestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TestRequest* other);
  friend void swap(TestRequest& a, TestRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestRequest* New() const final {
    return CreateMaybeMessage<TestRequest>(nullptr);
  }

  TestRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestRequest& from);
  void MergeFrom(const TestRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:ShadowVM.TestRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svm_2eproto;
};
// -------------------------------------------------------------------

class HelloReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShadowVM.HelloReply) */ {
 public:
  HelloReply();
  virtual ~HelloReply();

  HelloReply(const HelloReply& from);

  inline HelloReply& operator=(const HelloReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HelloReply(HelloReply&& from) noexcept
    : HelloReply() {
    *this = ::std::move(from);
  }

  inline HelloReply& operator=(HelloReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const HelloReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HelloReply* internal_default_instance() {
    return reinterpret_cast<const HelloReply*>(
               &_HelloReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(HelloReply* other);
  friend void swap(HelloReply& a, HelloReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HelloReply* New() const final {
    return CreateMaybeMessage<HelloReply>(nullptr);
  }

  HelloReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HelloReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HelloReply& from);
  void MergeFrom(const HelloReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:ShadowVM.HelloReply)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svm_2eproto;
};
// -------------------------------------------------------------------

class TestReply final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShadowVM.TestReply) */ {
 public:
  TestReply();
  virtual ~TestReply();

  TestReply(const TestReply& from);

  inline TestReply& operator=(const TestReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestReply(TestReply&& from) noexcept
    : TestReply() {
    *this = ::std::move(from);
  }

  inline TestReply& operator=(TestReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TestReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestReply* internal_default_instance() {
    return reinterpret_cast<const TestReply*>(
               &_TestReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TestReply* other);
  friend void swap(TestReply& a, TestReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestReply* New() const final {
    return CreateMaybeMessage<TestReply>(nullptr);
  }

  TestReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestReply& from);
  void MergeFrom(const TestReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:ShadowVM.TestReply)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svm_2eproto;
};
// -------------------------------------------------------------------

class BulkInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShadowVM.BulkInfo) */ {
 public:
  BulkInfo();
  virtual ~BulkInfo();

  BulkInfo(const BulkInfo& from);

  inline BulkInfo& operator=(const BulkInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BulkInfo(BulkInfo&& from) noexcept
    : BulkInfo() {
    *this = ::std::move(from);
  }

  inline BulkInfo& operator=(BulkInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BulkInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkInfo* internal_default_instance() {
    return reinterpret_cast<const BulkInfo*>(
               &_BulkInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BulkInfo* other);
  friend void swap(BulkInfo& a, BulkInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BulkInfo* New() const final {
    return CreateMaybeMessage<BulkInfo>(nullptr);
  }

  BulkInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BulkInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BulkInfo& from);
  void MergeFrom(const BulkInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::int64 count() const;
  void set_count(::google::protobuf::int64 value);

  // int64 size = 3;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::int64 size() const;
  void set_size(::google::protobuf::int64 value);

  // .ShadowVM.StoType stotype = 1;
  void clear_stotype();
  static const int kStotypeFieldNumber = 1;
  ::ShadowVM::StoType stotype() const;
  void set_stotype(::ShadowVM::StoType value);

  // @@protoc_insertion_point(class_scope:ShadowVM.BulkInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 count_;
  ::google::protobuf::int64 size_;
  int stotype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svm_2eproto;
};
// -------------------------------------------------------------------

class ColumnInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShadowVM.ColumnInfo) */ {
 public:
  ColumnInfo();
  virtual ~ColumnInfo();

  ColumnInfo(const ColumnInfo& from);

  inline ColumnInfo& operator=(const ColumnInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ColumnInfo(ColumnInfo&& from) noexcept
    : ColumnInfo() {
    *this = ::std::move(from);
  }

  inline ColumnInfo& operator=(ColumnInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ColumnInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnInfo* internal_default_instance() {
    return reinterpret_cast<const ColumnInfo*>(
               &_ColumnInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ColumnInfo* other);
  friend void swap(ColumnInfo& a, ColumnInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ColumnInfo* New() const final {
    return CreateMaybeMessage<ColumnInfo>(nullptr);
  }

  ColumnInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ColumnInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ColumnInfo& from);
  void MergeFrom(const ColumnInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 dim = 4;
  int dim_size() const;
  void clear_dim();
  static const int kDimFieldNumber = 4;
  ::google::protobuf::int32 dim(int index) const;
  void set_dim(int index, ::google::protobuf::int32 value);
  void add_dim(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      dim() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_dim();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .ShadowVM.ValType type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::ShadowVM::ValType type() const;
  void set_type(::ShadowVM::ValType value);

  // bool isnull = 3;
  void clear_isnull();
  static const int kIsnullFieldNumber = 3;
  bool isnull() const;
  void set_isnull(bool value);

  // int64 val_size = 5;
  void clear_val_size();
  static const int kValSizeFieldNumber = 5;
  ::google::protobuf::int64 val_size() const;
  void set_val_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ShadowVM.ColumnInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > dim_;
  mutable std::atomic<int> _dim_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  int type_;
  bool isnull_;
  ::google::protobuf::int64 val_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svm_2eproto;
};
// -------------------------------------------------------------------

class ObjectInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShadowVM.ObjectInfo) */ {
 public:
  ObjectInfo();
  virtual ~ObjectInfo();

  ObjectInfo(const ObjectInfo& from);

  inline ObjectInfo& operator=(const ObjectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectInfo(ObjectInfo&& from) noexcept
    : ObjectInfo() {
    *this = ::std::move(from);
  }

  inline ObjectInfo& operator=(ObjectInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ObjectInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectInfo* internal_default_instance() {
    return reinterpret_cast<const ObjectInfo*>(
               &_ObjectInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ObjectInfo* other);
  friend void swap(ObjectInfo& a, ObjectInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectInfo* New() const final {
    return CreateMaybeMessage<ObjectInfo>(nullptr);
  }

  ObjectInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectInfo& from);
  void MergeFrom(const ObjectInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ShadowVM.ColumnInfo column_list = 3;
  int column_list_size() const;
  void clear_column_list();
  static const int kColumnListFieldNumber = 3;
  ::ShadowVM::ColumnInfo* mutable_column_list(int index);
  ::google::protobuf::RepeatedPtrField< ::ShadowVM::ColumnInfo >*
      mutable_column_list();
  const ::ShadowVM::ColumnInfo& column_list(int index) const;
  ::ShadowVM::ColumnInfo* add_column_list();
  const ::google::protobuf::RepeatedPtrField< ::ShadowVM::ColumnInfo >&
      column_list() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string host = 2;
  void clear_host();
  static const int kHostFieldNumber = 2;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // string path = 5;
  void clear_path();
  static const int kPathFieldNumber = 5;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // .ShadowVM.StoType storage = 4;
  void clear_storage();
  static const int kStorageFieldNumber = 4;
  ::ShadowVM::StoType storage() const;
  void set_storage(::ShadowVM::StoType value);

  // @@protoc_insertion_point(class_scope:ShadowVM.ObjectInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ShadowVM::ColumnInfo > column_list_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  int storage_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svm_2eproto;
};
// -------------------------------------------------------------------

class DependencyInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShadowVM.DependencyInfo) */ {
 public:
  DependencyInfo();
  virtual ~DependencyInfo();

  DependencyInfo(const DependencyInfo& from);

  inline DependencyInfo& operator=(const DependencyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DependencyInfo(DependencyInfo&& from) noexcept
    : DependencyInfo() {
    *this = ::std::move(from);
  }

  inline DependencyInfo& operator=(DependencyInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DependencyInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DependencyInfo* internal_default_instance() {
    return reinterpret_cast<const DependencyInfo*>(
               &_DependencyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(DependencyInfo* other);
  friend void swap(DependencyInfo& a, DependencyInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DependencyInfo* New() const final {
    return CreateMaybeMessage<DependencyInfo>(nullptr);
  }

  DependencyInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DependencyInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DependencyInfo& from);
  void MergeFrom(const DependencyInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DependencyInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DependencyInfo_Type Type;
  static const Type Whole =
    DependencyInfo_Type_Whole;
  static const Type HashPartition =
    DependencyInfo_Type_HashPartition;
  static const Type RangePartition =
    DependencyInfo_Type_RangePartition;
  static inline bool Type_IsValid(int value) {
    return DependencyInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DependencyInfo_Type_Type_MIN;
  static const Type Type_MAX =
    DependencyInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DependencyInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return DependencyInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return DependencyInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return DependencyInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .ShadowVM.ObjectInfo pre_object = 1;
  bool has_pre_object() const;
  void clear_pre_object();
  static const int kPreObjectFieldNumber = 1;
  const ::ShadowVM::ObjectInfo& pre_object() const;
  ::ShadowVM::ObjectInfo* release_pre_object();
  ::ShadowVM::ObjectInfo* mutable_pre_object();
  void set_allocated_pre_object(::ShadowVM::ObjectInfo* pre_object);

  // .ShadowVM.DependencyInfo.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::ShadowVM::DependencyInfo_Type type() const;
  void set_type(::ShadowVM::DependencyInfo_Type value);

  // int32 shard_id = 3;
  void clear_shard_id();
  static const int kShardIdFieldNumber = 3;
  ::google::protobuf::int32 shard_id() const;
  void set_shard_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ShadowVM.DependencyInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ShadowVM::ObjectInfo* pre_object_;
  int type_;
  ::google::protobuf::int32 shard_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svm_2eproto;
};
// -------------------------------------------------------------------

class OperatorInfo_ArgsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<OperatorInfo_ArgsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<OperatorInfo_ArgsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  OperatorInfo_ArgsEntry_DoNotUse();
  OperatorInfo_ArgsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const OperatorInfo_ArgsEntry_DoNotUse& other);
  static const OperatorInfo_ArgsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OperatorInfo_ArgsEntry_DoNotUse*>(&_OperatorInfo_ArgsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class OperatorInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShadowVM.OperatorInfo) */ {
 public:
  OperatorInfo();
  virtual ~OperatorInfo();

  OperatorInfo(const OperatorInfo& from);

  inline OperatorInfo& operator=(const OperatorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperatorInfo(OperatorInfo&& from) noexcept
    : OperatorInfo() {
    *this = ::std::move(from);
  }

  inline OperatorInfo& operator=(OperatorInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const OperatorInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperatorInfo* internal_default_instance() {
    return reinterpret_cast<const OperatorInfo*>(
               &_OperatorInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(OperatorInfo* other);
  friend void swap(OperatorInfo& a, OperatorInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperatorInfo* New() const final {
    return CreateMaybeMessage<OperatorInfo>(nullptr);
  }

  OperatorInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OperatorInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OperatorInfo& from);
  void MergeFrom(const OperatorInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperatorInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef OperatorInfo_Type Type;
  static const Type Source =
    OperatorInfo_Type_Source;
  static const Type Loader =
    OperatorInfo_Type_Loader;
  static const Type Filter =
    OperatorInfo_Type_Filter;
  static const Type Map =
    OperatorInfo_Type_Map;
  static const Type ReduceBy =
    OperatorInfo_Type_ReduceBy;
  static const Type SortBy =
    OperatorInfo_Type_SortBy;
  static const Type JoinWith =
    OperatorInfo_Type_JoinWith;
  static const Type Sink =
    OperatorInfo_Type_Sink;
  static inline bool Type_IsValid(int value) {
    return OperatorInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    OperatorInfo_Type_Type_MIN;
  static const Type Type_MAX =
    OperatorInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    OperatorInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return OperatorInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return OperatorInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return OperatorInfo_Type_Parse(name, value);
  }

  typedef OperatorInfo_Preference Preference;
  static const Preference CPU =
    OperatorInfo_Preference_CPU;
  static const Preference GPU =
    OperatorInfo_Preference_GPU;
  static const Preference NO =
    OperatorInfo_Preference_NO;
  static inline bool Preference_IsValid(int value) {
    return OperatorInfo_Preference_IsValid(value);
  }
  static const Preference Preference_MIN =
    OperatorInfo_Preference_Preference_MIN;
  static const Preference Preference_MAX =
    OperatorInfo_Preference_Preference_MAX;
  static const int Preference_ARRAYSIZE =
    OperatorInfo_Preference_Preference_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Preference_descriptor() {
    return OperatorInfo_Preference_descriptor();
  }
  static inline const ::std::string& Preference_Name(Preference value) {
    return OperatorInfo_Preference_Name(value);
  }
  static inline bool Preference_Parse(const ::std::string& name,
      Preference* value) {
    return OperatorInfo_Preference_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .ShadowVM.DependencyInfo input = 3;
  int input_size() const;
  void clear_input();
  static const int kInputFieldNumber = 3;
  ::ShadowVM::DependencyInfo* mutable_input(int index);
  ::google::protobuf::RepeatedPtrField< ::ShadowVM::DependencyInfo >*
      mutable_input();
  const ::ShadowVM::DependencyInfo& input(int index) const;
  ::ShadowVM::DependencyInfo* add_input();
  const ::google::protobuf::RepeatedPtrField< ::ShadowVM::DependencyInfo >&
      input() const;

  // map<string, string> args = 4;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      args() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_args();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // .ShadowVM.ObjectInfo output = 5;
  bool has_output() const;
  void clear_output();
  static const int kOutputFieldNumber = 5;
  const ::ShadowVM::ObjectInfo& output() const;
  ::ShadowVM::ObjectInfo* release_output();
  ::ShadowVM::ObjectInfo* mutable_output();
  void set_allocated_output(::ShadowVM::ObjectInfo* output);

  // .ShadowVM.OperatorInfo.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::ShadowVM::OperatorInfo_Type type() const;
  void set_type(::ShadowVM::OperatorInfo_Type value);

  // .ShadowVM.OperatorInfo.Preference perf = 6;
  void clear_perf();
  static const int kPerfFieldNumber = 6;
  ::ShadowVM::OperatorInfo_Preference perf() const;
  void set_perf(::ShadowVM::OperatorInfo_Preference value);

  // @@protoc_insertion_point(class_scope:ShadowVM.OperatorInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ShadowVM::DependencyInfo > input_;
  ::google::protobuf::internal::MapField<
      OperatorInfo_ArgsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > args_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::ShadowVM::ObjectInfo* output_;
  int type_;
  int perf_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svm_2eproto;
};
// -------------------------------------------------------------------

class UDFInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShadowVM.UDFInfo) */ {
 public:
  UDFInfo();
  virtual ~UDFInfo();

  UDFInfo(const UDFInfo& from);

  inline UDFInfo& operator=(const UDFInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UDFInfo(UDFInfo&& from) noexcept
    : UDFInfo() {
    *this = ::std::move(from);
  }

  inline UDFInfo& operator=(UDFInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UDFInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UDFInfo* internal_default_instance() {
    return reinterpret_cast<const UDFInfo*>(
               &_UDFInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(UDFInfo* other);
  friend void swap(UDFInfo& a, UDFInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UDFInfo* New() const final {
    return CreateMaybeMessage<UDFInfo>(nullptr);
  }

  UDFInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UDFInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UDFInfo& from);
  void MergeFrom(const UDFInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UDFInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ShadowVM.ValType para_list = 2;
  int para_list_size() const;
  void clear_para_list();
  static const int kParaListFieldNumber = 2;
  ::ShadowVM::ValType para_list(int index) const;
  void set_para_list(int index, ::ShadowVM::ValType value);
  void add_para_list(::ShadowVM::ValType value);
  const ::google::protobuf::RepeatedField<int>& para_list() const;
  ::google::protobuf::RepeatedField<int>* mutable_para_list();

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string expression = 4;
  void clear_expression();
  static const int kExpressionFieldNumber = 4;
  const ::std::string& expression() const;
  void set_expression(const ::std::string& value);
  #if LANG_CXX11
  void set_expression(::std::string&& value);
  #endif
  void set_expression(const char* value);
  void set_expression(const char* value, size_t size);
  ::std::string* mutable_expression();
  ::std::string* release_expression();
  void set_allocated_expression(::std::string* expression);

  // .ShadowVM.ValType return = 3;
  void clear_return_();
  static const int kReturnFieldNumber = 3;
  ::ShadowVM::ValType return_() const;
  void set_return_(::ShadowVM::ValType value);

  // @@protoc_insertion_point(class_scope:ShadowVM.UDFInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField<int> para_list_;
  mutable std::atomic<int> _para_list_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr expression_;
  int return__;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svm_2eproto;
};
// -------------------------------------------------------------------

class PipelineInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShadowVM.PipelineInfo) */ {
 public:
  PipelineInfo();
  virtual ~PipelineInfo();

  PipelineInfo(const PipelineInfo& from);

  inline PipelineInfo& operator=(const PipelineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PipelineInfo(PipelineInfo&& from) noexcept
    : PipelineInfo() {
    *this = ::std::move(from);
  }

  inline PipelineInfo& operator=(PipelineInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PipelineInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PipelineInfo* internal_default_instance() {
    return reinterpret_cast<const PipelineInfo*>(
               &_PipelineInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(PipelineInfo* other);
  friend void swap(PipelineInfo& a, PipelineInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PipelineInfo* New() const final {
    return CreateMaybeMessage<PipelineInfo>(nullptr);
  }

  PipelineInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PipelineInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PipelineInfo& from);
  void MergeFrom(const PipelineInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PipelineInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ShadowVM.OperatorInfo workflow = 2;
  int workflow_size() const;
  void clear_workflow();
  static const int kWorkflowFieldNumber = 2;
  ::ShadowVM::OperatorInfo* mutable_workflow(int index);
  ::google::protobuf::RepeatedPtrField< ::ShadowVM::OperatorInfo >*
      mutable_workflow();
  const ::ShadowVM::OperatorInfo& workflow(int index) const;
  ::ShadowVM::OperatorInfo* add_workflow();
  const ::google::protobuf::RepeatedPtrField< ::ShadowVM::OperatorInfo >&
      workflow() const;

  // repeated string pre_pipeline_id = 3;
  int pre_pipeline_id_size() const;
  void clear_pre_pipeline_id();
  static const int kPrePipelineIdFieldNumber = 3;
  const ::std::string& pre_pipeline_id(int index) const;
  ::std::string* mutable_pre_pipeline_id(int index);
  void set_pre_pipeline_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_pre_pipeline_id(int index, ::std::string&& value);
  #endif
  void set_pre_pipeline_id(int index, const char* value);
  void set_pre_pipeline_id(int index, const char* value, size_t size);
  ::std::string* add_pre_pipeline_id();
  void add_pre_pipeline_id(const ::std::string& value);
  #if LANG_CXX11
  void add_pre_pipeline_id(::std::string&& value);
  #endif
  void add_pre_pipeline_id(const char* value);
  void add_pre_pipeline_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& pre_pipeline_id() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_pre_pipeline_id();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // bool codegen = 4;
  void clear_codegen();
  static const int kCodegenFieldNumber = 4;
  bool codegen() const;
  void set_codegen(bool value);

  // bool debug = 5;
  void clear_debug();
  static const int kDebugFieldNumber = 5;
  bool debug() const;
  void set_debug(bool value);

  // bool isGPU = 6;
  void clear_isgpu();
  static const int kIsGPUFieldNumber = 6;
  bool isgpu() const;
  void set_isgpu(bool value);

  // @@protoc_insertion_point(class_scope:ShadowVM.PipelineInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ShadowVM::OperatorInfo > workflow_;
  ::google::protobuf::RepeatedPtrField<::std::string> pre_pipeline_id_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  bool codegen_;
  bool debug_;
  bool isgpu_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svm_2eproto;
};
// -------------------------------------------------------------------

class GraphInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShadowVM.GraphInfo) */ {
 public:
  GraphInfo();
  virtual ~GraphInfo();

  GraphInfo(const GraphInfo& from);

  inline GraphInfo& operator=(const GraphInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GraphInfo(GraphInfo&& from) noexcept
    : GraphInfo() {
    *this = ::std::move(from);
  }

  inline GraphInfo& operator=(GraphInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GraphInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GraphInfo* internal_default_instance() {
    return reinterpret_cast<const GraphInfo*>(
               &_GraphInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GraphInfo* other);
  friend void swap(GraphInfo& a, GraphInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GraphInfo* New() const final {
    return CreateMaybeMessage<GraphInfo>(nullptr);
  }

  GraphInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GraphInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GraphInfo& from);
  void MergeFrom(const GraphInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GraphInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ShadowVM.PipelineInfo pipeline_list = 2;
  int pipeline_list_size() const;
  void clear_pipeline_list();
  static const int kPipelineListFieldNumber = 2;
  ::ShadowVM::PipelineInfo* mutable_pipeline_list(int index);
  ::google::protobuf::RepeatedPtrField< ::ShadowVM::PipelineInfo >*
      mutable_pipeline_list();
  const ::ShadowVM::PipelineInfo& pipeline_list(int index) const;
  ::ShadowVM::PipelineInfo* add_pipeline_list();
  const ::google::protobuf::RepeatedPtrField< ::ShadowVM::PipelineInfo >&
      pipeline_list() const;

  // repeated .ShadowVM.UDFInfo udf = 3;
  int udf_size() const;
  void clear_udf();
  static const int kUdfFieldNumber = 3;
  ::ShadowVM::UDFInfo* mutable_udf(int index);
  ::google::protobuf::RepeatedPtrField< ::ShadowVM::UDFInfo >*
      mutable_udf();
  const ::ShadowVM::UDFInfo& udf(int index) const;
  ::ShadowVM::UDFInfo* add_udf();
  const ::google::protobuf::RepeatedPtrField< ::ShadowVM::UDFInfo >&
      udf() const;

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:ShadowVM.GraphInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::ShadowVM::PipelineInfo > pipeline_list_;
  ::google::protobuf::RepeatedPtrField< ::ShadowVM::UDFInfo > udf_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svm_2eproto;
};
// -------------------------------------------------------------------

class Ret final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ShadowVM.Ret) */ {
 public:
  Ret();
  virtual ~Ret();

  Ret(const Ret& from);

  inline Ret& operator=(const Ret& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ret(Ret&& from) noexcept
    : Ret() {
    *this = ::std::move(from);
  }

  inline Ret& operator=(Ret&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Ret& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ret* internal_default_instance() {
    return reinterpret_cast<const Ret*>(
               &_Ret_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Ret* other);
  friend void swap(Ret& a, Ret& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ret* New() const final {
    return CreateMaybeMessage<Ret>(nullptr);
  }

  Ret* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ret>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ret& from);
  void MergeFrom(const Ret& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ret* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string info = 2;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:ShadowVM.Ret)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  bool success_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_svm_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HelloRequest::name() const {
  // @@protoc_insertion_point(field_get:ShadowVM.HelloRequest.name)
  return name_.GetNoArena();
}
inline void HelloRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.HelloRequest.name)
}
#if LANG_CXX11
inline void HelloRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.HelloRequest.name)
}
#endif
inline void HelloRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.HelloRequest.name)
}
inline void HelloRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.HelloRequest.name)
}
inline ::std::string* HelloRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.HelloRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:ShadowVM.HelloRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HelloRequest::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.HelloRequest.name)
}

// -------------------------------------------------------------------

// TestRequest

// string name = 1;
inline void TestRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TestRequest::name() const {
  // @@protoc_insertion_point(field_get:ShadowVM.TestRequest.name)
  return name_.GetNoArena();
}
inline void TestRequest::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.TestRequest.name)
}
#if LANG_CXX11
inline void TestRequest::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.TestRequest.name)
}
#endif
inline void TestRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.TestRequest.name)
}
inline void TestRequest::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.TestRequest.name)
}
inline ::std::string* TestRequest::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.TestRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestRequest::release_name() {
  // @@protoc_insertion_point(field_release:ShadowVM.TestRequest.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestRequest::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.TestRequest.name)
}

// -------------------------------------------------------------------

// HelloReply

// string message = 1;
inline void HelloReply::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HelloReply::message() const {
  // @@protoc_insertion_point(field_get:ShadowVM.HelloReply.message)
  return message_.GetNoArena();
}
inline void HelloReply::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.HelloReply.message)
}
#if LANG_CXX11
inline void HelloReply::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.HelloReply.message)
}
#endif
inline void HelloReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.HelloReply.message)
}
inline void HelloReply::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.HelloReply.message)
}
inline ::std::string* HelloReply::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.HelloReply.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HelloReply::release_message() {
  // @@protoc_insertion_point(field_release:ShadowVM.HelloReply.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HelloReply::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.HelloReply.message)
}

// -------------------------------------------------------------------

// TestReply

// string message = 1;
inline void TestReply::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TestReply::message() const {
  // @@protoc_insertion_point(field_get:ShadowVM.TestReply.message)
  return message_.GetNoArena();
}
inline void TestReply::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.TestReply.message)
}
#if LANG_CXX11
inline void TestReply::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.TestReply.message)
}
#endif
inline void TestReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.TestReply.message)
}
inline void TestReply::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.TestReply.message)
}
inline ::std::string* TestReply::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.TestReply.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestReply::release_message() {
  // @@protoc_insertion_point(field_release:ShadowVM.TestReply.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestReply::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.TestReply.message)
}

// -------------------------------------------------------------------

// BulkInfo

// .ShadowVM.StoType stotype = 1;
inline void BulkInfo::clear_stotype() {
  stotype_ = 0;
}
inline ::ShadowVM::StoType BulkInfo::stotype() const {
  // @@protoc_insertion_point(field_get:ShadowVM.BulkInfo.stotype)
  return static_cast< ::ShadowVM::StoType >(stotype_);
}
inline void BulkInfo::set_stotype(::ShadowVM::StoType value) {
  
  stotype_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.BulkInfo.stotype)
}

// int64 count = 2;
inline void BulkInfo::clear_count() {
  count_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 BulkInfo::count() const {
  // @@protoc_insertion_point(field_get:ShadowVM.BulkInfo.count)
  return count_;
}
inline void BulkInfo::set_count(::google::protobuf::int64 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.BulkInfo.count)
}

// int64 size = 3;
inline void BulkInfo::clear_size() {
  size_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 BulkInfo::size() const {
  // @@protoc_insertion_point(field_get:ShadowVM.BulkInfo.size)
  return size_;
}
inline void BulkInfo::set_size(::google::protobuf::int64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.BulkInfo.size)
}

// -------------------------------------------------------------------

// ColumnInfo

// string id = 1;
inline void ColumnInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ColumnInfo::id() const {
  // @@protoc_insertion_point(field_get:ShadowVM.ColumnInfo.id)
  return id_.GetNoArena();
}
inline void ColumnInfo::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.ColumnInfo.id)
}
#if LANG_CXX11
inline void ColumnInfo::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.ColumnInfo.id)
}
#endif
inline void ColumnInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.ColumnInfo.id)
}
inline void ColumnInfo::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.ColumnInfo.id)
}
inline ::std::string* ColumnInfo::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.ColumnInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnInfo::release_id() {
  // @@protoc_insertion_point(field_release:ShadowVM.ColumnInfo.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnInfo::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.ColumnInfo.id)
}

// .ShadowVM.ValType type = 2;
inline void ColumnInfo::clear_type() {
  type_ = 0;
}
inline ::ShadowVM::ValType ColumnInfo::type() const {
  // @@protoc_insertion_point(field_get:ShadowVM.ColumnInfo.type)
  return static_cast< ::ShadowVM::ValType >(type_);
}
inline void ColumnInfo::set_type(::ShadowVM::ValType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.ColumnInfo.type)
}

// bool isnull = 3;
inline void ColumnInfo::clear_isnull() {
  isnull_ = false;
}
inline bool ColumnInfo::isnull() const {
  // @@protoc_insertion_point(field_get:ShadowVM.ColumnInfo.isnull)
  return isnull_;
}
inline void ColumnInfo::set_isnull(bool value) {
  
  isnull_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.ColumnInfo.isnull)
}

// repeated int32 dim = 4;
inline int ColumnInfo::dim_size() const {
  return dim_.size();
}
inline void ColumnInfo::clear_dim() {
  dim_.Clear();
}
inline ::google::protobuf::int32 ColumnInfo::dim(int index) const {
  // @@protoc_insertion_point(field_get:ShadowVM.ColumnInfo.dim)
  return dim_.Get(index);
}
inline void ColumnInfo::set_dim(int index, ::google::protobuf::int32 value) {
  dim_.Set(index, value);
  // @@protoc_insertion_point(field_set:ShadowVM.ColumnInfo.dim)
}
inline void ColumnInfo::add_dim(::google::protobuf::int32 value) {
  dim_.Add(value);
  // @@protoc_insertion_point(field_add:ShadowVM.ColumnInfo.dim)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ColumnInfo::dim() const {
  // @@protoc_insertion_point(field_list:ShadowVM.ColumnInfo.dim)
  return dim_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ColumnInfo::mutable_dim() {
  // @@protoc_insertion_point(field_mutable_list:ShadowVM.ColumnInfo.dim)
  return &dim_;
}

// int64 val_size = 5;
inline void ColumnInfo::clear_val_size() {
  val_size_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 ColumnInfo::val_size() const {
  // @@protoc_insertion_point(field_get:ShadowVM.ColumnInfo.val_size)
  return val_size_;
}
inline void ColumnInfo::set_val_size(::google::protobuf::int64 value) {
  
  val_size_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.ColumnInfo.val_size)
}

// -------------------------------------------------------------------

// ObjectInfo

// string id = 1;
inline void ObjectInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ObjectInfo::id() const {
  // @@protoc_insertion_point(field_get:ShadowVM.ObjectInfo.id)
  return id_.GetNoArena();
}
inline void ObjectInfo::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.ObjectInfo.id)
}
#if LANG_CXX11
inline void ObjectInfo::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.ObjectInfo.id)
}
#endif
inline void ObjectInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.ObjectInfo.id)
}
inline void ObjectInfo::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.ObjectInfo.id)
}
inline ::std::string* ObjectInfo::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.ObjectInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObjectInfo::release_id() {
  // @@protoc_insertion_point(field_release:ShadowVM.ObjectInfo.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObjectInfo::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.ObjectInfo.id)
}

// string host = 2;
inline void ObjectInfo::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ObjectInfo::host() const {
  // @@protoc_insertion_point(field_get:ShadowVM.ObjectInfo.host)
  return host_.GetNoArena();
}
inline void ObjectInfo::set_host(const ::std::string& value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.ObjectInfo.host)
}
#if LANG_CXX11
inline void ObjectInfo::set_host(::std::string&& value) {
  
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.ObjectInfo.host)
}
#endif
inline void ObjectInfo::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.ObjectInfo.host)
}
inline void ObjectInfo::set_host(const char* value, size_t size) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.ObjectInfo.host)
}
inline ::std::string* ObjectInfo::mutable_host() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.ObjectInfo.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObjectInfo::release_host() {
  // @@protoc_insertion_point(field_release:ShadowVM.ObjectInfo.host)
  
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObjectInfo::set_allocated_host(::std::string* host) {
  if (host != nullptr) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.ObjectInfo.host)
}

// repeated .ShadowVM.ColumnInfo column_list = 3;
inline int ObjectInfo::column_list_size() const {
  return column_list_.size();
}
inline void ObjectInfo::clear_column_list() {
  column_list_.Clear();
}
inline ::ShadowVM::ColumnInfo* ObjectInfo::mutable_column_list(int index) {
  // @@protoc_insertion_point(field_mutable:ShadowVM.ObjectInfo.column_list)
  return column_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ShadowVM::ColumnInfo >*
ObjectInfo::mutable_column_list() {
  // @@protoc_insertion_point(field_mutable_list:ShadowVM.ObjectInfo.column_list)
  return &column_list_;
}
inline const ::ShadowVM::ColumnInfo& ObjectInfo::column_list(int index) const {
  // @@protoc_insertion_point(field_get:ShadowVM.ObjectInfo.column_list)
  return column_list_.Get(index);
}
inline ::ShadowVM::ColumnInfo* ObjectInfo::add_column_list() {
  // @@protoc_insertion_point(field_add:ShadowVM.ObjectInfo.column_list)
  return column_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShadowVM::ColumnInfo >&
ObjectInfo::column_list() const {
  // @@protoc_insertion_point(field_list:ShadowVM.ObjectInfo.column_list)
  return column_list_;
}

// .ShadowVM.StoType storage = 4;
inline void ObjectInfo::clear_storage() {
  storage_ = 0;
}
inline ::ShadowVM::StoType ObjectInfo::storage() const {
  // @@protoc_insertion_point(field_get:ShadowVM.ObjectInfo.storage)
  return static_cast< ::ShadowVM::StoType >(storage_);
}
inline void ObjectInfo::set_storage(::ShadowVM::StoType value) {
  
  storage_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.ObjectInfo.storage)
}

// string path = 5;
inline void ObjectInfo::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ObjectInfo::path() const {
  // @@protoc_insertion_point(field_get:ShadowVM.ObjectInfo.path)
  return path_.GetNoArena();
}
inline void ObjectInfo::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.ObjectInfo.path)
}
#if LANG_CXX11
inline void ObjectInfo::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.ObjectInfo.path)
}
#endif
inline void ObjectInfo::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.ObjectInfo.path)
}
inline void ObjectInfo::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.ObjectInfo.path)
}
inline ::std::string* ObjectInfo::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.ObjectInfo.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObjectInfo::release_path() {
  // @@protoc_insertion_point(field_release:ShadowVM.ObjectInfo.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObjectInfo::set_allocated_path(::std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.ObjectInfo.path)
}

// -------------------------------------------------------------------

// DependencyInfo

// .ShadowVM.ObjectInfo pre_object = 1;
inline bool DependencyInfo::has_pre_object() const {
  return this != internal_default_instance() && pre_object_ != nullptr;
}
inline void DependencyInfo::clear_pre_object() {
  if (GetArenaNoVirtual() == nullptr && pre_object_ != nullptr) {
    delete pre_object_;
  }
  pre_object_ = nullptr;
}
inline const ::ShadowVM::ObjectInfo& DependencyInfo::pre_object() const {
  const ::ShadowVM::ObjectInfo* p = pre_object_;
  // @@protoc_insertion_point(field_get:ShadowVM.DependencyInfo.pre_object)
  return p != nullptr ? *p : *reinterpret_cast<const ::ShadowVM::ObjectInfo*>(
      &::ShadowVM::_ObjectInfo_default_instance_);
}
inline ::ShadowVM::ObjectInfo* DependencyInfo::release_pre_object() {
  // @@protoc_insertion_point(field_release:ShadowVM.DependencyInfo.pre_object)
  
  ::ShadowVM::ObjectInfo* temp = pre_object_;
  pre_object_ = nullptr;
  return temp;
}
inline ::ShadowVM::ObjectInfo* DependencyInfo::mutable_pre_object() {
  
  if (pre_object_ == nullptr) {
    auto* p = CreateMaybeMessage<::ShadowVM::ObjectInfo>(GetArenaNoVirtual());
    pre_object_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ShadowVM.DependencyInfo.pre_object)
  return pre_object_;
}
inline void DependencyInfo::set_allocated_pre_object(::ShadowVM::ObjectInfo* pre_object) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pre_object_;
  }
  if (pre_object) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pre_object = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pre_object, submessage_arena);
    }
    
  } else {
    
  }
  pre_object_ = pre_object;
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.DependencyInfo.pre_object)
}

// .ShadowVM.DependencyInfo.Type type = 2;
inline void DependencyInfo::clear_type() {
  type_ = 0;
}
inline ::ShadowVM::DependencyInfo_Type DependencyInfo::type() const {
  // @@protoc_insertion_point(field_get:ShadowVM.DependencyInfo.type)
  return static_cast< ::ShadowVM::DependencyInfo_Type >(type_);
}
inline void DependencyInfo::set_type(::ShadowVM::DependencyInfo_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.DependencyInfo.type)
}

// int32 shard_id = 3;
inline void DependencyInfo::clear_shard_id() {
  shard_id_ = 0;
}
inline ::google::protobuf::int32 DependencyInfo::shard_id() const {
  // @@protoc_insertion_point(field_get:ShadowVM.DependencyInfo.shard_id)
  return shard_id_;
}
inline void DependencyInfo::set_shard_id(::google::protobuf::int32 value) {
  
  shard_id_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.DependencyInfo.shard_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OperatorInfo

// string id = 1;
inline void OperatorInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OperatorInfo::id() const {
  // @@protoc_insertion_point(field_get:ShadowVM.OperatorInfo.id)
  return id_.GetNoArena();
}
inline void OperatorInfo::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.OperatorInfo.id)
}
#if LANG_CXX11
inline void OperatorInfo::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.OperatorInfo.id)
}
#endif
inline void OperatorInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.OperatorInfo.id)
}
inline void OperatorInfo::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.OperatorInfo.id)
}
inline ::std::string* OperatorInfo::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.OperatorInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperatorInfo::release_id() {
  // @@protoc_insertion_point(field_release:ShadowVM.OperatorInfo.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperatorInfo::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.OperatorInfo.id)
}

// .ShadowVM.OperatorInfo.Type type = 2;
inline void OperatorInfo::clear_type() {
  type_ = 0;
}
inline ::ShadowVM::OperatorInfo_Type OperatorInfo::type() const {
  // @@protoc_insertion_point(field_get:ShadowVM.OperatorInfo.type)
  return static_cast< ::ShadowVM::OperatorInfo_Type >(type_);
}
inline void OperatorInfo::set_type(::ShadowVM::OperatorInfo_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.OperatorInfo.type)
}

// repeated .ShadowVM.DependencyInfo input = 3;
inline int OperatorInfo::input_size() const {
  return input_.size();
}
inline void OperatorInfo::clear_input() {
  input_.Clear();
}
inline ::ShadowVM::DependencyInfo* OperatorInfo::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:ShadowVM.OperatorInfo.input)
  return input_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ShadowVM::DependencyInfo >*
OperatorInfo::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:ShadowVM.OperatorInfo.input)
  return &input_;
}
inline const ::ShadowVM::DependencyInfo& OperatorInfo::input(int index) const {
  // @@protoc_insertion_point(field_get:ShadowVM.OperatorInfo.input)
  return input_.Get(index);
}
inline ::ShadowVM::DependencyInfo* OperatorInfo::add_input() {
  // @@protoc_insertion_point(field_add:ShadowVM.OperatorInfo.input)
  return input_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShadowVM::DependencyInfo >&
OperatorInfo::input() const {
  // @@protoc_insertion_point(field_list:ShadowVM.OperatorInfo.input)
  return input_;
}

// map<string, string> args = 4;
inline int OperatorInfo::args_size() const {
  return args_.size();
}
inline void OperatorInfo::clear_args() {
  args_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
OperatorInfo::args() const {
  // @@protoc_insertion_point(field_map:ShadowVM.OperatorInfo.args)
  return args_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
OperatorInfo::mutable_args() {
  // @@protoc_insertion_point(field_mutable_map:ShadowVM.OperatorInfo.args)
  return args_.MutableMap();
}

// .ShadowVM.ObjectInfo output = 5;
inline bool OperatorInfo::has_output() const {
  return this != internal_default_instance() && output_ != nullptr;
}
inline void OperatorInfo::clear_output() {
  if (GetArenaNoVirtual() == nullptr && output_ != nullptr) {
    delete output_;
  }
  output_ = nullptr;
}
inline const ::ShadowVM::ObjectInfo& OperatorInfo::output() const {
  const ::ShadowVM::ObjectInfo* p = output_;
  // @@protoc_insertion_point(field_get:ShadowVM.OperatorInfo.output)
  return p != nullptr ? *p : *reinterpret_cast<const ::ShadowVM::ObjectInfo*>(
      &::ShadowVM::_ObjectInfo_default_instance_);
}
inline ::ShadowVM::ObjectInfo* OperatorInfo::release_output() {
  // @@protoc_insertion_point(field_release:ShadowVM.OperatorInfo.output)
  
  ::ShadowVM::ObjectInfo* temp = output_;
  output_ = nullptr;
  return temp;
}
inline ::ShadowVM::ObjectInfo* OperatorInfo::mutable_output() {
  
  if (output_ == nullptr) {
    auto* p = CreateMaybeMessage<::ShadowVM::ObjectInfo>(GetArenaNoVirtual());
    output_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ShadowVM.OperatorInfo.output)
  return output_;
}
inline void OperatorInfo::set_allocated_output(::ShadowVM::ObjectInfo* output) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete output_;
  }
  if (output) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      output = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, output, submessage_arena);
    }
    
  } else {
    
  }
  output_ = output;
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.OperatorInfo.output)
}

// .ShadowVM.OperatorInfo.Preference perf = 6;
inline void OperatorInfo::clear_perf() {
  perf_ = 0;
}
inline ::ShadowVM::OperatorInfo_Preference OperatorInfo::perf() const {
  // @@protoc_insertion_point(field_get:ShadowVM.OperatorInfo.perf)
  return static_cast< ::ShadowVM::OperatorInfo_Preference >(perf_);
}
inline void OperatorInfo::set_perf(::ShadowVM::OperatorInfo_Preference value) {
  
  perf_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.OperatorInfo.perf)
}

// -------------------------------------------------------------------

// UDFInfo

// string name = 1;
inline void UDFInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UDFInfo::name() const {
  // @@protoc_insertion_point(field_get:ShadowVM.UDFInfo.name)
  return name_.GetNoArena();
}
inline void UDFInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.UDFInfo.name)
}
#if LANG_CXX11
inline void UDFInfo::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.UDFInfo.name)
}
#endif
inline void UDFInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.UDFInfo.name)
}
inline void UDFInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.UDFInfo.name)
}
inline ::std::string* UDFInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.UDFInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UDFInfo::release_name() {
  // @@protoc_insertion_point(field_release:ShadowVM.UDFInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UDFInfo::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.UDFInfo.name)
}

// repeated .ShadowVM.ValType para_list = 2;
inline int UDFInfo::para_list_size() const {
  return para_list_.size();
}
inline void UDFInfo::clear_para_list() {
  para_list_.Clear();
}
inline ::ShadowVM::ValType UDFInfo::para_list(int index) const {
  // @@protoc_insertion_point(field_get:ShadowVM.UDFInfo.para_list)
  return static_cast< ::ShadowVM::ValType >(para_list_.Get(index));
}
inline void UDFInfo::set_para_list(int index, ::ShadowVM::ValType value) {
  para_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:ShadowVM.UDFInfo.para_list)
}
inline void UDFInfo::add_para_list(::ShadowVM::ValType value) {
  para_list_.Add(value);
  // @@protoc_insertion_point(field_add:ShadowVM.UDFInfo.para_list)
}
inline const ::google::protobuf::RepeatedField<int>&
UDFInfo::para_list() const {
  // @@protoc_insertion_point(field_list:ShadowVM.UDFInfo.para_list)
  return para_list_;
}
inline ::google::protobuf::RepeatedField<int>*
UDFInfo::mutable_para_list() {
  // @@protoc_insertion_point(field_mutable_list:ShadowVM.UDFInfo.para_list)
  return &para_list_;
}

// .ShadowVM.ValType return = 3;
inline void UDFInfo::clear_return_() {
  return__ = 0;
}
inline ::ShadowVM::ValType UDFInfo::return_() const {
  // @@protoc_insertion_point(field_get:ShadowVM.UDFInfo.return)
  return static_cast< ::ShadowVM::ValType >(return__);
}
inline void UDFInfo::set_return_(::ShadowVM::ValType value) {
  
  return__ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.UDFInfo.return)
}

// string expression = 4;
inline void UDFInfo::clear_expression() {
  expression_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UDFInfo::expression() const {
  // @@protoc_insertion_point(field_get:ShadowVM.UDFInfo.expression)
  return expression_.GetNoArena();
}
inline void UDFInfo::set_expression(const ::std::string& value) {
  
  expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.UDFInfo.expression)
}
#if LANG_CXX11
inline void UDFInfo::set_expression(::std::string&& value) {
  
  expression_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.UDFInfo.expression)
}
#endif
inline void UDFInfo::set_expression(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.UDFInfo.expression)
}
inline void UDFInfo::set_expression(const char* value, size_t size) {
  
  expression_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.UDFInfo.expression)
}
inline ::std::string* UDFInfo::mutable_expression() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.UDFInfo.expression)
  return expression_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UDFInfo::release_expression() {
  // @@protoc_insertion_point(field_release:ShadowVM.UDFInfo.expression)
  
  return expression_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UDFInfo::set_allocated_expression(::std::string* expression) {
  if (expression != nullptr) {
    
  } else {
    
  }
  expression_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), expression);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.UDFInfo.expression)
}

// -------------------------------------------------------------------

// PipelineInfo

// string id = 1;
inline void PipelineInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PipelineInfo::id() const {
  // @@protoc_insertion_point(field_get:ShadowVM.PipelineInfo.id)
  return id_.GetNoArena();
}
inline void PipelineInfo::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.PipelineInfo.id)
}
#if LANG_CXX11
inline void PipelineInfo::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.PipelineInfo.id)
}
#endif
inline void PipelineInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.PipelineInfo.id)
}
inline void PipelineInfo::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.PipelineInfo.id)
}
inline ::std::string* PipelineInfo::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.PipelineInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PipelineInfo::release_id() {
  // @@protoc_insertion_point(field_release:ShadowVM.PipelineInfo.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PipelineInfo::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.PipelineInfo.id)
}

// repeated .ShadowVM.OperatorInfo workflow = 2;
inline int PipelineInfo::workflow_size() const {
  return workflow_.size();
}
inline void PipelineInfo::clear_workflow() {
  workflow_.Clear();
}
inline ::ShadowVM::OperatorInfo* PipelineInfo::mutable_workflow(int index) {
  // @@protoc_insertion_point(field_mutable:ShadowVM.PipelineInfo.workflow)
  return workflow_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ShadowVM::OperatorInfo >*
PipelineInfo::mutable_workflow() {
  // @@protoc_insertion_point(field_mutable_list:ShadowVM.PipelineInfo.workflow)
  return &workflow_;
}
inline const ::ShadowVM::OperatorInfo& PipelineInfo::workflow(int index) const {
  // @@protoc_insertion_point(field_get:ShadowVM.PipelineInfo.workflow)
  return workflow_.Get(index);
}
inline ::ShadowVM::OperatorInfo* PipelineInfo::add_workflow() {
  // @@protoc_insertion_point(field_add:ShadowVM.PipelineInfo.workflow)
  return workflow_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShadowVM::OperatorInfo >&
PipelineInfo::workflow() const {
  // @@protoc_insertion_point(field_list:ShadowVM.PipelineInfo.workflow)
  return workflow_;
}

// repeated string pre_pipeline_id = 3;
inline int PipelineInfo::pre_pipeline_id_size() const {
  return pre_pipeline_id_.size();
}
inline void PipelineInfo::clear_pre_pipeline_id() {
  pre_pipeline_id_.Clear();
}
inline const ::std::string& PipelineInfo::pre_pipeline_id(int index) const {
  // @@protoc_insertion_point(field_get:ShadowVM.PipelineInfo.pre_pipeline_id)
  return pre_pipeline_id_.Get(index);
}
inline ::std::string* PipelineInfo::mutable_pre_pipeline_id(int index) {
  // @@protoc_insertion_point(field_mutable:ShadowVM.PipelineInfo.pre_pipeline_id)
  return pre_pipeline_id_.Mutable(index);
}
inline void PipelineInfo::set_pre_pipeline_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ShadowVM.PipelineInfo.pre_pipeline_id)
  pre_pipeline_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PipelineInfo::set_pre_pipeline_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ShadowVM.PipelineInfo.pre_pipeline_id)
  pre_pipeline_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PipelineInfo::set_pre_pipeline_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  pre_pipeline_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ShadowVM.PipelineInfo.pre_pipeline_id)
}
inline void PipelineInfo::set_pre_pipeline_id(int index, const char* value, size_t size) {
  pre_pipeline_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.PipelineInfo.pre_pipeline_id)
}
inline ::std::string* PipelineInfo::add_pre_pipeline_id() {
  // @@protoc_insertion_point(field_add_mutable:ShadowVM.PipelineInfo.pre_pipeline_id)
  return pre_pipeline_id_.Add();
}
inline void PipelineInfo::add_pre_pipeline_id(const ::std::string& value) {
  pre_pipeline_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ShadowVM.PipelineInfo.pre_pipeline_id)
}
#if LANG_CXX11
inline void PipelineInfo::add_pre_pipeline_id(::std::string&& value) {
  pre_pipeline_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ShadowVM.PipelineInfo.pre_pipeline_id)
}
#endif
inline void PipelineInfo::add_pre_pipeline_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  pre_pipeline_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ShadowVM.PipelineInfo.pre_pipeline_id)
}
inline void PipelineInfo::add_pre_pipeline_id(const char* value, size_t size) {
  pre_pipeline_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ShadowVM.PipelineInfo.pre_pipeline_id)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
PipelineInfo::pre_pipeline_id() const {
  // @@protoc_insertion_point(field_list:ShadowVM.PipelineInfo.pre_pipeline_id)
  return pre_pipeline_id_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
PipelineInfo::mutable_pre_pipeline_id() {
  // @@protoc_insertion_point(field_mutable_list:ShadowVM.PipelineInfo.pre_pipeline_id)
  return &pre_pipeline_id_;
}

// bool codegen = 4;
inline void PipelineInfo::clear_codegen() {
  codegen_ = false;
}
inline bool PipelineInfo::codegen() const {
  // @@protoc_insertion_point(field_get:ShadowVM.PipelineInfo.codegen)
  return codegen_;
}
inline void PipelineInfo::set_codegen(bool value) {
  
  codegen_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.PipelineInfo.codegen)
}

// bool debug = 5;
inline void PipelineInfo::clear_debug() {
  debug_ = false;
}
inline bool PipelineInfo::debug() const {
  // @@protoc_insertion_point(field_get:ShadowVM.PipelineInfo.debug)
  return debug_;
}
inline void PipelineInfo::set_debug(bool value) {
  
  debug_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.PipelineInfo.debug)
}

// bool isGPU = 6;
inline void PipelineInfo::clear_isgpu() {
  isgpu_ = false;
}
inline bool PipelineInfo::isgpu() const {
  // @@protoc_insertion_point(field_get:ShadowVM.PipelineInfo.isGPU)
  return isgpu_;
}
inline void PipelineInfo::set_isgpu(bool value) {
  
  isgpu_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.PipelineInfo.isGPU)
}

// -------------------------------------------------------------------

// GraphInfo

// string id = 1;
inline void GraphInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GraphInfo::id() const {
  // @@protoc_insertion_point(field_get:ShadowVM.GraphInfo.id)
  return id_.GetNoArena();
}
inline void GraphInfo::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.GraphInfo.id)
}
#if LANG_CXX11
inline void GraphInfo::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.GraphInfo.id)
}
#endif
inline void GraphInfo::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.GraphInfo.id)
}
inline void GraphInfo::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.GraphInfo.id)
}
inline ::std::string* GraphInfo::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.GraphInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GraphInfo::release_id() {
  // @@protoc_insertion_point(field_release:ShadowVM.GraphInfo.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GraphInfo::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.GraphInfo.id)
}

// repeated .ShadowVM.PipelineInfo pipeline_list = 2;
inline int GraphInfo::pipeline_list_size() const {
  return pipeline_list_.size();
}
inline void GraphInfo::clear_pipeline_list() {
  pipeline_list_.Clear();
}
inline ::ShadowVM::PipelineInfo* GraphInfo::mutable_pipeline_list(int index) {
  // @@protoc_insertion_point(field_mutable:ShadowVM.GraphInfo.pipeline_list)
  return pipeline_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ShadowVM::PipelineInfo >*
GraphInfo::mutable_pipeline_list() {
  // @@protoc_insertion_point(field_mutable_list:ShadowVM.GraphInfo.pipeline_list)
  return &pipeline_list_;
}
inline const ::ShadowVM::PipelineInfo& GraphInfo::pipeline_list(int index) const {
  // @@protoc_insertion_point(field_get:ShadowVM.GraphInfo.pipeline_list)
  return pipeline_list_.Get(index);
}
inline ::ShadowVM::PipelineInfo* GraphInfo::add_pipeline_list() {
  // @@protoc_insertion_point(field_add:ShadowVM.GraphInfo.pipeline_list)
  return pipeline_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShadowVM::PipelineInfo >&
GraphInfo::pipeline_list() const {
  // @@protoc_insertion_point(field_list:ShadowVM.GraphInfo.pipeline_list)
  return pipeline_list_;
}

// repeated .ShadowVM.UDFInfo udf = 3;
inline int GraphInfo::udf_size() const {
  return udf_.size();
}
inline void GraphInfo::clear_udf() {
  udf_.Clear();
}
inline ::ShadowVM::UDFInfo* GraphInfo::mutable_udf(int index) {
  // @@protoc_insertion_point(field_mutable:ShadowVM.GraphInfo.udf)
  return udf_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ShadowVM::UDFInfo >*
GraphInfo::mutable_udf() {
  // @@protoc_insertion_point(field_mutable_list:ShadowVM.GraphInfo.udf)
  return &udf_;
}
inline const ::ShadowVM::UDFInfo& GraphInfo::udf(int index) const {
  // @@protoc_insertion_point(field_get:ShadowVM.GraphInfo.udf)
  return udf_.Get(index);
}
inline ::ShadowVM::UDFInfo* GraphInfo::add_udf() {
  // @@protoc_insertion_point(field_add:ShadowVM.GraphInfo.udf)
  return udf_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ShadowVM::UDFInfo >&
GraphInfo::udf() const {
  // @@protoc_insertion_point(field_list:ShadowVM.GraphInfo.udf)
  return udf_;
}

// -------------------------------------------------------------------

// Ret

// bool success = 1;
inline void Ret::clear_success() {
  success_ = false;
}
inline bool Ret::success() const {
  // @@protoc_insertion_point(field_get:ShadowVM.Ret.success)
  return success_;
}
inline void Ret::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:ShadowVM.Ret.success)
}

// string info = 2;
inline void Ret::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Ret::info() const {
  // @@protoc_insertion_point(field_get:ShadowVM.Ret.info)
  return info_.GetNoArena();
}
inline void Ret::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ShadowVM.Ret.info)
}
#if LANG_CXX11
inline void Ret::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ShadowVM.Ret.info)
}
#endif
inline void Ret::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ShadowVM.Ret.info)
}
inline void Ret::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ShadowVM.Ret.info)
}
inline ::std::string* Ret::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:ShadowVM.Ret.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Ret::release_info() {
  // @@protoc_insertion_point(field_release:ShadowVM.Ret.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Ret::set_allocated_info(::std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:ShadowVM.Ret.info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ShadowVM

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ShadowVM::DependencyInfo_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ShadowVM::DependencyInfo_Type>() {
  return ::ShadowVM::DependencyInfo_Type_descriptor();
}
template <> struct is_proto_enum< ::ShadowVM::OperatorInfo_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ShadowVM::OperatorInfo_Type>() {
  return ::ShadowVM::OperatorInfo_Type_descriptor();
}
template <> struct is_proto_enum< ::ShadowVM::OperatorInfo_Preference> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ShadowVM::OperatorInfo_Preference>() {
  return ::ShadowVM::OperatorInfo_Preference_descriptor();
}
template <> struct is_proto_enum< ::ShadowVM::StoType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ShadowVM::StoType>() {
  return ::ShadowVM::StoType_descriptor();
}
template <> struct is_proto_enum< ::ShadowVM::ValType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ShadowVM::ValType>() {
  return ::ShadowVM::ValType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_svm_2eproto
